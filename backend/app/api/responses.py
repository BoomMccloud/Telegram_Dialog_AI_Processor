"""
API Router for managing AI-generated responses

This module provides endpoints for retrieving, reviewing, and managing
responses generated by the Claude processor.
"""

from fastapi import APIRouter, HTTPException, status, Depends
from typing import Dict, List, Optional, Any
from pydantic import BaseModel
from enum import Enum

from app.services.auth import get_or_load_session
from app.middleware.session_middleware import verify_session
from app.db.database import get_raw_connection

router = APIRouter(prefix="/api/responses", tags=["responses"])

class ResponseStatus(str, Enum):
    """Status of a generated response"""
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    MODIFIED = "modified"
    SENT = "sent"

class ResponseAction(BaseModel):
    """Action to take on a response"""
    status: ResponseStatus
    modified_text: Optional[str] = None
    comment: Optional[str] = None

class ResponseFilter(BaseModel):
    """Filter parameters for response listing"""
    dialog_id: Optional[int] = None
    status: Optional[ResponseStatus] = None
    limit: Optional[int] = 50
    offset: Optional[int] = 0

@router.get("/{session_id}", dependencies=[Depends(verify_session)])
async def list_responses(
    session_id: str,
    dialog_id: Optional[int] = None,
    status: Optional[str] = None,
    limit: int = 50,
    offset: int = 0
) -> Dict[str, Any]:
    """
    List responses for the current user
    
    Args:
        session_id: User's session ID
        dialog_id: Optional filter by dialog ID
        status: Optional filter by response status
        limit: Maximum number of responses to return
        offset: Offset for pagination
        
    Returns:
        Dictionary with responses and count
    """
    session = get_or_load_session(session_id)
    user_id = session.get("user_id")
    
    # Build the SQL query based on filters
    query_conditions = ["user_id = $1"]
    query_params = [user_id]
    param_counter = 2
    
    if dialog_id is not None:
        query_conditions.append(f"dialog_id = ${param_counter}")
        query_params.append(dialog_id)
        param_counter += 1
        
    if status is not None:
        query_conditions.append(f"status = ${param_counter}")
        query_params.append(status)
        param_counter += 1
        
    # Build the final query
    conditions = " AND ".join(query_conditions)
    
    conn = await get_raw_connection()
    
    try:
        # Get total count
        count_query = f"SELECT COUNT(*) as count FROM processed_responses WHERE {conditions}"
        count_row = await conn.fetchrow(count_query, *query_params)
        total_count = count_row["count"] if count_row else 0
        
        # Get paginated results
        query = f"""
        SELECT 
            id, message_id, dialog_id, user_id, 
            response_text, model_name, status,
            modified_text, review_comment,
            created_at, updated_at
        FROM processed_responses 
        WHERE {conditions}
        ORDER BY created_at DESC
        LIMIT ${param_counter} OFFSET ${param_counter + 1}
        """
        
        query_params.extend([limit, offset])
        rows = await conn.fetch(query, *query_params)
        
        # Convert rows to dictionaries
        responses = [dict(row) for row in rows]
        
        # Get dialog names for each response
        dialog_ids = {response["dialog_id"] for response in responses}
        if dialog_ids:
            dialog_query = """
            SELECT dialog_id, title 
            FROM dialogs 
            WHERE dialog_id = ANY($1)
            """
            dialog_rows = await conn.fetch(dialog_query, list(dialog_ids))
            dialog_map = {row["dialog_id"]: row["title"] for row in dialog_rows}
            
            # Add dialog titles to responses
            for response in responses:
                response["dialog_title"] = dialog_map.get(response["dialog_id"], "Unknown Dialog")
        
        return {
            "total": total_count,
            "offset": offset,
            "limit": limit,
            "responses": responses
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to fetch responses: {str(e)}"
        )
    finally:
        await conn.close()

@router.get("/{session_id}/{response_id}", dependencies=[Depends(verify_session)])
async def get_response(
    session_id: str,
    response_id: int
) -> Dict[str, Any]:
    """
    Get details for a specific response
    
    Args:
        session_id: User's session ID
        response_id: ID of the response to retrieve
        
    Returns:
        Response details with context
    """
    session = get_or_load_session(session_id)
    user_id = session.get("user_id")
    
    conn = await get_raw_connection()
    
    try:
        # Get the response
        query = """
        SELECT 
            id, message_id, dialog_id, user_id, 
            response_text, model_name, system_prompt,
            context_messages, status, modified_text,
            review_comment, created_at, updated_at
        FROM processed_responses 
        WHERE id = $1 AND user_id = $2
        """
        
        row = await conn.fetchrow(query, response_id, user_id)
        
        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Response with ID {response_id} not found"
            )
            
        response = dict(row)
        
        # Get dialog title
        dialog_query = "SELECT title FROM dialogs WHERE dialog_id = $1"
        dialog_row = await conn.fetchrow(dialog_query, response["dialog_id"])
        response["dialog_title"] = dialog_row["title"] if dialog_row else "Unknown Dialog"
        
        # Get message text
        message_query = "SELECT message_text FROM message_history WHERE message_id = $1"
        message_row = await conn.fetchrow(message_query, response["message_id"])
        response["message_text"] = message_row["message_text"] if message_row else ""
        
        return response
        
    except Exception as e:
        if isinstance(e, HTTPException):
            raise e
            
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to fetch response: {str(e)}"
        )
    finally:
        await conn.close()

@router.post("/{session_id}/{response_id}/review", dependencies=[Depends(verify_session)])
async def review_response(
    session_id: str,
    response_id: int,
    action: ResponseAction
) -> Dict[str, Any]:
    """
    Review a response (approve, reject, or modify)
    
    Args:
        session_id: User's session ID
        response_id: ID of the response to review
        action: Action to take on the response
        
    Returns:
        Updated response details
    """
    session = get_or_load_session(session_id)
    user_id = session.get("user_id")
    
    conn = await get_raw_connection()
    
    try:
        # Check if response exists and belongs to user
        check_query = """
        SELECT id FROM processed_responses 
        WHERE id = $1 AND user_id = $2
        """
        
        row = await conn.fetchrow(check_query, response_id, user_id)
        
        if not row:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Response with ID {response_id} not found"
            )
            
        # Update response status
        update_query = """
        UPDATE processed_responses 
        SET 
            status = $1, 
            modified_text = $2,
            review_comment = $3,
            updated_at = NOW()
        WHERE id = $4 AND user_id = $5
        RETURNING 
            id, message_id, dialog_id, 
            response_text, status, created_at, updated_at
        """
        
        row = await conn.fetchrow(
            update_query, 
            action.status, 
            action.modified_text if action.status == ResponseStatus.MODIFIED else None,
            action.comment,
            response_id, 
            user_id
        )
        
        result = dict(row)
        result["message"] = f"Response marked as {action.status}"
        
        # If response is approved, check if it should be sent automatically
        # This would be implemented in a later version with telegram sending capability
        
        return result
        
    except Exception as e:
        if isinstance(e, HTTPException):
            raise e
            
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to review response: {str(e)}"
        )
    finally:
        await conn.close()

@router.post("/{session_id}/{response_id}/send", dependencies=[Depends(verify_session)])
async def send_response(
    session_id: str,
    response_id: int
) -> Dict[str, Any]:
    """
    Send an approved response to the Telegram chat
    
    Args:
        session_id: User's session ID
        response_id: ID of the response to send
        
    Returns:
        Status of the send operation
    """
    session = get_or_load_session(session_id)
    user_id = session.get("user_id")
    
    # This is a placeholder for future functionality
    # In a future version, this would send the message via Telethon API
    
    return {
        "success": True,
        "message": "Response sending will be implemented in a future version",
        "response_id": response_id
    } 